// Argument

// 강의: Argument처리 메커니즘, Argument처리구조,
// -엔진의 파라미터 처리

// Argument처리구조

/* function get() {
  return arguments;
}
console.log(get("A", "B")); */
// 함수가 호출되면 우선, 아규먼트 오브젝트를 만든다.
// 그리고 거기에
// 파라미터를 {key:value}형태로 저장
// 근데 파라미터만 적었으니까
// key가 없잖아? 그래서 0부터 해서 인덱스를 부여한다.
// 그래서 파라미터 수만큼 0부터 인덱스 부여해서
// key로 사용한다.
// 파라미터로 받은 값을 value에 설정
// {0:param1, 1:param2}

// 이 형태를 Array-like라고 한다.
// 반드시 key값이 0부터 1씩 증가한다.
// 그리고 length 프로퍼티가 있어야 함.
// length가 있다는 것은 for문으로 돌릴 수 있다는 것이다.
// 아마 그래서 Array-'like'라고 한 것 같다.
// 프로퍼티지만 Array처럼 처리할 수 있다는 뜻

// 엔진의 파라미터 처리
/* const get = function (one) {
  return one;
};
get(77, 100); */

// 1. get()함수를 호출하면서
// 77과 100을 파라미터 값으로 넘겨 준다.

// 2. 넘겨 받은 값을 함수의 파라미터 이름에 설정(맵핑)
// 정적환경의 선언적 환경 레코드에 아래와 같은 형태로 설정
// one:77
// 스코프 개념으로 정의을 하는 것이다.
// 따라서 return one(표현식)을 했을 때
// 표현식을 평가하게 되는데,
// 이때 선언적 환경 레코드에서 one을 찾아서
// 77을 리턴해준다.
// 이게 식별자 해결과 선언적 환경 레코드의 역할이다.

// 3. Argument오브젝트를 생성합니다.
// 이것은 파라미터로 받은 모~든 값을 설정하는 것이다.(앞에서 배움)

// 4. 넘겨받은 파라미터 수를
// Argument오브젝트의 length프로퍼티에 설정
// Array-like

// 5. 넘겨받은 파라미터 수만큼 반복하면서
// 0부터 key로 하여 순서대로 파라미터 값을 설정
// {0:77},{1:100}형태가 된다.

// 6. 함수의 초기화 단계에서 실행
// 즉, 함수 안에서 환경을 설정하는 단계에서 진행

/**
 * ----------------------------------
 * ----------------------------------
 * ----------------------------------
 * ----------------------------------
 * ----------------------------------
 * ----------------------------------
 * ----------------------------------
 * ---------------------------------- **/

// 스코프

// 강의: 스코프 목적, 스코프 설정

// 스코프의 목적

// 범위를 제한하여
// 식별자를 해결하려는 것이다.
// 스코프(영역)에서 식별자를 해결

// 식별자 해결이란
// 변수이름, 함수이름을 찾는 것이다.
// '어디서 찾아야 될까?'라는 질문을 할 때,
// 이때 스코프를 사용한다.

// 이름을 찾게 되면 값을 구할 수 있다.
// 이게 식별자 해결의 궁극적 목적이다.
// 크게는 이름을 설정하는 것도 식별자 해결이다.
// 등록과 검색의 행위로 나눌 수 있다. => 식별자 해결

// 스코프는 식별자 해결을 위한 것

// 스코프 설정
/* function book() {
  const point = 123;
  function get() {
    console.log(point);
  }
  get();
}
book(); */
// 1. 엔진이 function book(){}을 만나면,

// 2. function오브젝트를 생성하고

// 3. 스코프를 설정합니다.
// 생성한 function 오브젝트의 내부 프로퍼티인
// [[Scope]]에 스코프를 설정한다.
// 즉, 이때 스코프가 결정된다.

// function오브젝트를 만드는 시점에 스코프를 결정하는 것을
// 정적 스코프라고 한다.

// 반면 함수를 호출할 때 스코프를 설정하는 것이
// 동적 스코프라고 한다.

// 4. 마지막 줄에서 book()함수를 호출한다.

// 5. 엔진 컨트롤이 book함수 안으로 이동한다.
// 여기서 book()함수를 호출하게 되면
// 함수 안에서 함수 선언문을 찾는다.
// 이후 get function오브젝트를 생성한다.

// 6. 스코프를 설정합니다.
// function오브젝트의 [[Scope]]에 스코프를 설정한다.
// 이때 스코프가 결정된다.

// 7. get() 함수를 호출한다.

// 강의: Global오브젝트, 글로벌 오브젝트 특징

/* var value = 100;
function book() {
  var point = 200;
  return value;
}
book(); */

// var value = 100에서
// 100을 value변수에 할당한 것은
// value로 검색하여 값을 사용하기 위한 것이다.

// 함수 안에 변수를 선언하면,
// 변수가 함수에 속하게 되지만

// value변수는 함수 안에 작성되어 있지 않음.
// value변수가 속하는 오브젝트가 없으며
// 이때, 글로벌 오브젝트에 설정됩니다.

// 이런 메커니즘을 구현할 수 있는 것은
// 글로벌 오브젝트가 하나만 있기 때문이다.

// 오브젝트가 하나이므로 굳이 오브젝트를 작성하지 않더라도
// 글로벌 오브젝트에 속하게 해준다는 것은 좋았었다.
// 지금은 굉장히 많은 오브젝트를 사용하게 되고
// 약간의 문제가 발생하긴 하지만,
// 그래도 오브젝트가 없을때는
// 글로벌 오브젝트에 속하게 해준다는 것은
// 그 접근이 괜찮았다.

// 글로벌 오브젝트의 특정
/* var value = 100;
function book() {
  return value + 50;
}
book();
// <다른 파일>
console.log(value);
console.log(book()); */

// js소스 파일 전체에서
// 글로벌 오브젝트는 하나만 있다.
// new 연산자로 인스턴스 생성 불가

// js소스 파일 전체를 기준은
// <script>에 작성된 모든 코드이다.
// 모든 코드에서 사용 가능

// 다른 파일의 코드에서
// 글로벌 오브젝트에 작성된 변수 value 값을 출력하고
// book()함수를 호출할 수 있다.

// 강의: Global 스코프
