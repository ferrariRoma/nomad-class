// 논리적 정리

// 강의: 재귀 함수, 프로퍼티 연동 방지,
// -재귀 함수 형태,[정리시간]

// 재귀 함수

// 프로퍼티 연동 방지
// Object에 Object를 할당하면
// 프로퍼티 값이 연동된다.

// Object 할당
/* var origin = { member: 100 };
var dup = origin;
dup.member = 200;
console.log(origin.member); */

// origin오브젝트를 dup변수에 할당한 후
// dup.member에 200을 설정하면
// origin.member 값이 '연동'되어 바뀐다.
// 오브젝트를 할당하면 값을 공유하기 때문이다.

// 배열도 마찬가지로 연동된다.

// 배열 할당
/* var origin = [1, 2, 3];
var dup = origin;
dup[1] = 200;
console.log(origin); */

// 연동 방지: 프로퍼티 단위로 할당해야 한다.
// Object나 배열로 할당하면 안된다.

// 프로퍼티 단위로 할당
/* var origin = { member: 100 };
var dup = {};
for (var name in origin) {
  dup[name] = origin[name];
}
dup.member = 200;
console.log(origin.member);
console.log(dup.member); */

// 재귀 함수

// 함수 안에서 자신을 호출

// 사용 사례
// {name: {name: {name:value}}}
// [[1,2],[3,4],[5,6]]

/* var book = {
  member: { name: 100 },
  point: { value: 200 },
};
function show(param) {
  for (var type in param) {
    typeof param[type] === "object"
      ? show(param[type])
      : console.log(type + ":", param[type]);
  }
}
show(book); */

// 강의: 즉시 실행 함수

// 함수 즉시 실행이란,
// 엔진이 함수를 만났을 때
// 자동으로 함수를 실행한다.
// 즉시에 실행하므로 즉시 실행 함수

/* (function () {
  console.log("JS북");
})(); */

// IIFL: Immediateyl Invoked 'Function Expression'

// function(){...}()형태
// 함수 이름이 없으므로,
// 함수 선언문, 함수 표현식도 아니다.
// 문법 에러가 발생하지 않음.
// 무명 함수, 익명 함수라고도 한다.

// 함수 즉시 실행 과정

// 표현식을 평가
// 소괄호()는 그룹핑 연산자
/* var total = (1 + 2);
console.log(total); */

// (1+2)는 그룹핑 연산자이며, 1+2는 표현식이다.
// 그룹핑 연산자는 소괄호 안의 표현식을 평가하고
// 평가 결과를 반환한다. 저장도 안함.
// 소괄호()와 표현식 평가가 키포인트이다.

// 함수 이름 필요
// 함수에 이름이 없으면 문법 에러
/* var value = function () {
  return 100;
};
console.log(value()); */

// value변수를 선언하지 않으면 함수 이름이 없으므로
// 문법 에러가 난다. 여기서 ()는 그룹핑 연산자가 아니라,
// 함수를 호출하는 역할이다.

// 함수 표현식 끝에 소괄호 작성
/* var value = (function () {
  return 100;
})();
console.log(value); */

// 소괄호를 붙이므로써 함수를 바로 호출하였다.

// 소괄호()에 함수 작성
/* var value = (function () {
  return 100;
}());
console.log(value); */

// 밖의 소괄호는 그룹핑, 안의 소괄호는 실행

// 함수 즉시 실행 과정

// 그룹핑 연산자에서 반환된 값이
// 할당되는 변수를 작성하지 않은 형태
// }()처럼 소괄호를 끝에 작성 가능하다.
/* (function () {
  console.log(100);
}()); */

// 그룹핑 연산자를 작성하지 않으면
// 함수 이름이 없으므로 문법 에러가 난다.
// 하지만, 그룹핑 연산자를 작성하면,
// 표현식에 function을 작성한 것이므로,
// 문법 에러가 발생하지 않습니다.
// 즉, (1+2)에서 1+2대신에 함수를 작성한 것

// 평가 결과는 메모리에 잠깐 저장하고
// 평가 결과를 반환하면 지워진다.

// function(){}코드로 만든 오브젝트도
// 메모리에 저장되지 않으며, 실행 결과도 저장되지 않는다.
// 그래서 저장해야 할 것이 있다면, 표현식 밖의 변수,
// 프로퍼티에 저장해야 한다.

// 저장할 필요가 없는 1회성 코드이면서,
// 엔진이 function키워드를 만나는 시점에
// 즉시 실행해야 한다면, 그룹핑 연산자 안에 표현식으로 작성!

// 무명 함수는 그룹핑 연산자 안의 코드를
// '한 번만 사용할 때' 사용한다.
// '주로 초깃값을 설정할 때 사용'한다.

// 강의: 클로저(Closure)논리, 클로저 논리 전개,
// -[정리 시간]

// Closure란 function오브젝트를 생성할 때,
// 함수가 속한 스코프를 [[Scope]]에 설정하고,

// 함수가 호출되었을 때
// [[Scope]]의 프로퍼티를 사용하는 메커니즘

// [[Scope]]의 설정과 사용 방법을 이해하면
// 클로저는 단지 논리적인 설명이다.

// 클로저 논리

/* 실행 콘텍스트:{
    렉시컬 환경 컴포넌트:{
        환경 레코드:{
            선언적 환경 레코드:{},
            오브젝트 환경 레코드:{}
        },
        '외부 렉시컬 환경 참조':{}
    }
} */

// 실행 중인 function오브젝트에 작성한 변수, 함수를
// 선언적 환경 레코드에 설정한다.

// [[Scope]]의 변수, 함수를
// 외부 렉시컬 환경 참조에 바인딩

// 변수 이름으로 접근하여
// 값을 사용하거나 변경할 수 있다.
// 함수를 호출할 수 있음.

// 이런 개념이 클로저 논리이다.
// 외부 렉시컬에 있는 것을 마치 내것처럼
// 사용하겠다는 것이다.

/* function book() {
  var point = 100;
  var getPoint = function (param) {
    point = point + param;
    return point;
  };
  return getPoint;
}
var obj = book();
console.log(obj(200)); */
// 위 코드에서는 var obj = book();이 과정에서
// getPoint()의 클로저가 만들어진다.

// ----실행 준비 단계----

// 실행 콘텍스트를 생성하게 되고

// 3개의 컴포넌트가 생성된다.
// 렉시컬/변수 환경 컴포넌트, this바인딩 컴포넌트

// 그리고 book function오브젝트의 [[Scope]]를
// 외부 렉시컬 환경 참조에 바인딩을 한다.

// <이까지 모습> - book function오브젝트의 실행 콘텍스트
/* 실행 콘텍스트:{
    렉시컬 환경 컴포넌트:{
        환경 레코드:{
            선언적 환경 레코드:{},
            오브젝트 환경 레코드:{}
        },
        외부 렉시컬 환경 참조:{[[Scope]]}
    },
    변수 환경 컴포넌트 = {Same}
    this 바인딩 컴포넌트: {}
} */

// ----초기화 및 실행 단계----

// 변수를 초기화 하고(undefined),
// var point; var getPoint;
// 변수 이름을 선언적 환경 레코드에 설정

// 이제 실행을 한다!
// var point = 100;
// 선언적 환경 레코드의 point에 100할당

// var getPoint = function(param){코드};
// getPoint function오브젝트 생성해서
// 스코프를 [[Scope]]에 바인딩된다.
// point:100이 [[Scope]]에 바인딩된다.

// <아래는 바인딩 범위>
// var point = 100;
// var getPoint = function (param) {
//   point = point + param;
//   return point;
// };
// return getPoint;

// <여기까지의 모습>
/* 실행 콘텍스트:{
    렉시컬 환경 컴포넌트:{
        환경 레코드:{
            선언적 환경 레코드:{},
            오브젝트 환경 레코드:{
                point: 100
            }
        },
        외부 렉시컬 환경 참조:{[[Scope]]}
    },
    변수 환경 컴포넌트 = {Same}
    this 바인딩 컴포넌트: {}
} */

// return getPoint오브젝트를 반환한다.

// var obj에 getPoint에서 반환한
// getPoint function오브젝트를 할당.

// console.log(obj(200));
// obj()를 호출하면, getPoint(200)함수가 호출된다.

// 클로저와 관련된 부분만 추려보면 아래 처리를 하게 된다.

// ====클로저 관련 부분====

// 세 번째로 실행 콘텍스트를 생성하고
// getPoint를 호출하면,
// getPoint오브젝트의 [[Scope]]를
// 외부 렉시컬 환경 참조에 바인딩

// 파라미터 이름에 값을 매핑하고
// 결과를 선언적 환경 레코드에 설정

// <여기까지의 모습>
/* 실행 콘텍스트:{
    렉시컬 환경 컴포넌트:{
        환경 레코드:{
            선언적 환경 레코드:{
                param: 200
            },
            오브젝트 환경 레코드:{
                point: 100
            }
        },
        외부 렉시컬 환경 참조:{[[Scope]]}
    },
    변수 환경 컴포넌트 = {Same}
    this 바인딩 컴포넌트: {}
} */

// 함수 안의 코드를 실행
// point = point + param;
// point를 선언적 환경 레코드에서 식별자 해결 시도를 하지만,
// 없으니까 외부 렉시컬 환경 참조에서 식별자를 해결한다.
// point가 있으며 값이 100.

// param을 선언적 환경 레코드에서 식별자 해결

// 이처럼 변수가 선언적 환경 레코드에 없으면
// 외부 렉시컬 환경 참조에서 식별자를 해결한다.
// 이것이 클로저 논리이다.

// 강의: 클로저와 무명 함수, JS에서 클로저

// 무명 함수 안에 작성한 값, 함수는
// 무명 함수가 끝나면 지워진다.
// 따라서 다시 사용하려면 저장이 필요하다.
// 한편, 무명 함수는 원래 저장하지 않으려는 의도로 사용

// 이때 클로저를 활용하면 두 가지 목적을 달성할 수 있다.
// 클로저는 함수 밖 스코프의
// 변수와 함수를 사용할 수 있다.
// 변수는 외부에서 직접 접근할 수 없으므로 정보 보호

// 무명 함수 안에서 클로저 변수를 가진 함수를 '반환'하면
// 함수의 재사용과 정보 보호를 할 수 있다.
// 두 마리 토끼를 잡을 수 있다.

/* var book = (function () {
  var point = 100;
  function getPoint(param) {
    return point + param;
  }
  return getPoint;
  // return을 해주면서
  // 함수가 날라가지 않고 저장이 되었다.
  // point변수와 getPoint[[Scope]] 모두.
}());
console.log(book(200)); */

// JS에서 클로저
// 함수에서 함수 밖의 변수 사용은
// JS의 기본 메커니즘이다.

// 논리적인 근거는
// 외부 렉시컬 환경 참조에
// 함수가 '속한' 스코프가 설정되기 때문이다.

// 클로저는 이를 나타내는 용어이다.
// 용어보다 논리적 구조를 이해해야 한다!
